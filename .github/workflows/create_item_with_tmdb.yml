# .github/workflows/create_item_with_tmdb.yml
name: Crear item (url+nombre+grupo) y completar con TMDB (es-MX)

permissions:
  contents: write

on:
  workflow_dispatch:
    inputs:
      video_url:
        description: "URL del video"
        required: true
      nombre:
        description: "Nombre (puede estar en ES o EN)"
        required: true
      grupo:
        description: "Grupo (se guarda en record.name)"
        required: true
      output_dir:
        description: "Carpeta de salida en la raiz"
        required: false
        default: "tmdb_manual_create"
      language:
        description: "Idioma TMDB (LatAm recomendado: es-MX)"
        required: false
        default: "es-MX"
      fallback_language:
        description: "Idioma fallback (en-US recomendado)"
        required: false
        default: "en-US"

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          persist-credentials: true

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Install dependencies
        run: |
          pip install --no-cache-dir requests

      - name: Create item and enrich with TMDB
        env:
          TMDB_API_KEY: ${{ secrets.TMDB_API_KEY }}
          VIDEO_URL: ${{ github.event.inputs.video_url }}
          NOMBRE: ${{ github.event.inputs.nombre }}
          GRUPO: ${{ github.event.inputs.grupo }}
          OUTPUT_DIR: ${{ github.event.inputs.output_dir }}
          LANGUAGE: ${{ github.event.inputs.language }}
          FALLBACK_LANGUAGE: ${{ github.event.inputs.fallback_language }}
        run: |
          python <<'PY'
          import os
          import re
          import json
          import time
          import requests
          from datetime import datetime

          API_KEY = (os.environ.get("TMDB_API_KEY") or "").strip()
          VIDEO_URL = (os.environ.get("VIDEO_URL") or "").strip()
          NOMBRE = (os.environ.get("NOMBRE") or "").strip()
          GRUPO = (os.environ.get("GRUPO") or "").strip()
          OUTPUT_DIR = (os.environ.get("OUTPUT_DIR") or "tmdb_manual_create").strip()
          LANGUAGE = (os.environ.get("LANGUAGE") or "es-MX").strip()
          FALLBACK_LANGUAGE = (os.environ.get("FALLBACK_LANGUAGE") or "en-US").strip()

          if not API_KEY:
              raise SystemExit("Falta secrets.TMDB_API_KEY")
          if not VIDEO_URL or not NOMBRE or not GRUPO:
              raise SystemExit("Faltan inputs: video_url, nombre, grupo")

          os.makedirs(OUTPUT_DIR, exist_ok=True)

          TMDB_BASE = "https://api.themoviedb.org/3"
          IMG_BASE = "https://image.tmdb.org/t/p/original"

          # --- throttle suave ---
          _last_call = 0.0
          def _throttle(min_delay_ms=150):
              global _last_call
              now = time.time()
              wait = (min_delay_ms/1000.0) - (now - _last_call)
              if wait > 0:
                  time.sleep(wait)
              _last_call = time.time()

          def tmdb_get(path, params=None, retries=4):
              url = TMDB_BASE + path
              params = dict(params or {})
              params["api_key"] = API_KEY

              for attempt in range(retries):
                  _throttle(150)
                  r = requests.get(url, params=params, timeout=30)
                  if r.status_code == 429:
                      ra = int(r.headers.get("Retry-After", "2") or "2")
                      time.sleep(ra + 1 + attempt)
                      continue
                  if 500 <= r.status_code < 600:
                      time.sleep(1 + attempt)
                      continue
                  r.raise_for_status()
                  return r.json()

              r.raise_for_status()
              return r.json()

          # --- Normalizacion del nombre para buscar mejor ---
          YEAR_RE = re.compile(r"\b(19\d{2}|20\d{2})\b")
          BRACKETS_RE = re.compile(r"[\[\(\{].*?[\]\)\}]")
          SEP_RE = re.compile(r"[._\-]+")
          MULTISPACE_RE = re.compile(r"\s{2,}")
          JUNK_RE = re.compile(
              r"(\b(1080p|720p|2160p|4k|hdr|sdr|webrip|web-dl|bluray|brrip|dvdrip|x264|x265|h\.?264|h\.?265|hevc|aac|ac3|dts|latino|castellano|subtitulado|sub|dual|multi|esp|eng|vose)\b)",
              re.IGNORECASE,
          )

          def extract_year(text: str) -> str:
              yrs = YEAR_RE.findall(text or "")
              return yrs[-1] if yrs else ""

          def clean_title(name: str) -> str:
              t = (name or "").strip()
              t = BRACKETS_RE.sub(" ", t)
              t = SEP_RE.sub(" ", t)
              t = JUNK_RE.sub(" ", t)
              t = re.sub(r"\s+\b(19\d{2}|20\d{2})\b\s*$", "", t).strip()
              t = MULTISPACE_RE.sub(" ", t).strip()
              return t

          def search_movie(query: str, year: str, lang: str):
              params = {"language": lang, "query": query, "include_adult": "false"}
              if year:
                  params["year"] = year
              res = tmdb_get("/search/movie", params=params)
              return res.get("results", []) or []

          def fetch_details(movie_id: int, lang: str):
              det = tmdb_get(f"/movie/{movie_id}", params={"language": lang})
              imgs = tmdb_get(f"/movie/{movie_id}/images", params={"include_image_language": "es,en,null"})
              return det, imgs

          def to_img_url(path: str) -> str:
              return (IMG_BASE + path) if path else ""

          def pick_logo_url(imgs: dict) -> str:
              logos = (imgs or {}).get("logos") or []
              def score(x):
                  iso = x.get("iso_639_1")
                  if iso == "es":
                      return 0
                  if iso == "en":
                      return 1
                  if iso in (None, "", "null"):
                      return 2
                  return 3
              logos_sorted = sorted(logos, key=score)
              if not logos_sorted:
                  return ""
              fp = logos_sorted[0].get("file_path") or ""
              return (IMG_BASE + fp) if fp else ""

          # --- Construir item base (todo vacio excepto url/nombre/grupo/type) ---
          orig_year = extract_year(NOMBRE)

          record = {
              "name": GRUPO,
              "samples": [{
                  "name": NOMBRE,
                  "url": VIDEO_URL,
                  "icono": "",
                  "iconoHorizontal": "",
                  "iconpng": "",
                  "type": "PELICULA",
                  "descripcion": "",
                  "anio": orig_year,
                  "genero": "",
                  "duracion": ""
              }]
          }

          # --- Enriquecer con TMDB ---
          q = clean_title(NOMBRE)
          year_for_search = orig_year

          results = search_movie(q, year_for_search, LANGUAGE)
          if not results and year_for_search:
              results = search_movie(q, "", LANGUAGE)
          if not results:
              results = search_movie(q, year_for_search, "en-US")
          if not results and year_for_search:
              results = search_movie(q, "", "en-US")

          enriched = False
          if results:
              movie = results[0]
              mid = movie.get("id")
              if mid:
                  det, imgs = fetch_details(mid, LANGUAGE)

                  det_fb = None
                  if FALLBACK_LANGUAGE and FALLBACK_LANGUAGE != LANGUAGE:
                      try:
                          det_fb, _ = fetch_details(mid, FALLBACK_LANGUAGE)
                      except Exception:
                          det_fb = None

                  title = (det.get("title") or "").strip()
                  overview = (det.get("overview") or "").strip()
                  if det_fb:
                      if not title:
                          title = (det_fb.get("title") or "").strip()
                      if not overview:
                          overview = (det_fb.get("overview") or "").strip()

                  release_date = (det.get("release_date") or "").strip()
                  tmdb_year = release_date[:4] if release_date else ""
                  runtime = det.get("runtime") or 0
                  genres = [g.get("name","").strip() for g in (det.get("genres") or []) if g.get("name")]

                  poster = to_img_url(det.get("poster_path") or "")
                  backdrop = to_img_url(det.get("backdrop_path") or "")
                  logo = pick_logo_url(imgs)

                  s = record["samples"][0]
                  if title:
                      s["name"] = title
                  if overview:
                      s["descripcion"] = overview
                  if tmdb_year:
                      s["anio"] = tmdb_year
                  if genres:
                      s["genero"] = ", ".join(genres)
                  if runtime:
                      s["duracion"] = f"{int(runtime)} min"
                  if poster:
                      s["icono"] = poster
                  if backdrop:
                      s["iconoHorizontal"] = backdrop
                  if logo:
                      s["iconpng"] = logo

                  # (opcional) si queres que el grupo se auto-ajuste al genero cuando lo dejas vacio,
                  # aca NO lo hacemos porque vos lo ingresas manualmente.
                  enriched = True

          # --- Guardar/actualizar archivo acumulado items.json en OUTPUT_DIR ---
          # Si existe un sample con misma URL, lo reemplaza (update)
          items_path = os.path.join(OUTPUT_DIR, "items.json")
          items = []
          if os.path.exists(items_path):
              try:
                  with open(items_path, "r", encoding="utf-8") as f:
                      items = json.load(f) or []
              except Exception:
                  items = []

          def same_url(rec):
              try:
                  smps = rec.get("samples") or []
                  return bool(smps) and (smps[0].get("url") or "").strip() == VIDEO_URL
              except Exception:
                  return False

          replaced = False
          for i in range(len(items)):
              if same_url(items[i]):
                  items[i] = record
                  replaced = True
                  break
          if not replaced:
              items.append(record)

          with open(items_path, "w", encoding="utf-8") as f:
              json.dump(items, f, indent=2, ensure_ascii=False)

          # Guardar "ultimo creado" para debug/uso rapido
          last_path = os.path.join(OUTPUT_DIR, "last_created.json")
          with open(last_path, "w", encoding="utf-8") as f:
              json.dump(record, f, indent=2, ensure_ascii=False)

          # Reporte
          report = {
              "timestamp_utc": datetime.utcnow().isoformat() + "Z",
              "input": {"url": VIDEO_URL, "nombre": NOMBRE, "grupo": GRUPO},
              "enriched": enriched,
              "language": LANGUAGE,
              "fallback_language": FALLBACK_LANGUAGE,
              "items_total": len(items),
              "replaced_existing": replaced,
              "output_dir": OUTPUT_DIR
          }
          with open(os.path.join(OUTPUT_DIR, "report.json"), "w", encoding="utf-8") as f:
              json.dump(report, f, indent=2, ensure_ascii=False)

          print(json.dumps(report, indent=2, ensure_ascii=False))
          PY

      - name: Commit and Push
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add "${{ github.event.inputs.output_dir }}"
          if ! git diff --cached --exit-code; then
            git commit -m "Crear item manual y enriquecer con TMDB"
            git push
          else
            echo "No hay cambios"
          fi
